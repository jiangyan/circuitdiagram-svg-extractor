# Circuit Diagram SVG Connection Extractor

## Project Overview

This tool extracts wire connections from circuit diagram SVG files generated by Adobe Illustrator. It parses connector IDs, pin numbers, wire specifications (diameter and color), and produces a complete connection table.

## Core Algorithm: Wire-Centric Approach

### The Key Insight

Instead of trying to assign pins to connectors using spatial boundaries, we **start from the wires** and work outward:

1. **Find all wire specifications** (e.g., "0.35,GY/PU")
2. **For each wire, find the pins on both ends** of the horizontal line
3. **For each pin, look up which connector is directly above it**

This approach avoids the complexity of:
- Determining which pins "belong" to which connector when pins are far below labels
- Handling multiple connector instances of the same type
- Dealing with interleaved connectors of different types

### Algorithm Steps

```
For each wire specification in the SVG:
    1. Find all pins on the same horizontal line (±10 Y units)
    2. Identify the leftmost pin right of wire spec (source)
    3. Identify the rightmost pin left of wire spec (destination)
    4. For left pin: find closest connector above (prefer FL2* variants for junctions)
    5. For right pin: find closest connector above (prefer *2FL variants for junctions)
    6. Create connection: (left_connector, left_pin) → (right_connector, right_pin)
    7. Skip if this pin-pair already processed (deduplication)
```

## Critical Design Decisions

### 1. Wire-Centric vs Pin-Centric

**❌ Pin-Centric (Failed Approach):**
- Try to assign pins to connectors based on spatial proximity
- Problem: Pins can be located far below their connector, past other connector labels
- Problem: Boundary-based approaches fail when connectors are interleaved

**✓ Wire-Centric (Successful Approach):**
- Let the wires dictate the connections
- Simple rule: find the connector directly above each pin
- No boundaries, no complex spatial logic

### 2. Y-Axis Tolerance: ±10 Units

**Why this matters:**
- Wire specifications and pins must be on the same horizontal row
- Too large (±20): Groups pins from different rows → wrong connections
- Too small (±5): Misses valid pins due to SVG rendering variations
- **±10 units** is the sweet spot for Adobe Illustrator SVG exports

**Example of the problem at ±20:**
```
Pin 25 at Y=611.17  }  24.8 units apart
Pin 8  at Y=586.38  }  ← Both matched to wire at Y=604.9
→ Algorithm picks pin 8 (closer horizontally) instead of pin 25
```

### 3. Junction Connector Handling

Circuit diagrams use bidirectional junction connectors that share pins:

**Junction Pairs:**
- `MH2FL` ↔ `FL2MH` (Main to Front-Left junction)
- `FTL2FL` ↔ `FL2FTL` (Front-To-Left junction)

**Rule:**
- `*2FL` variants = **destinations** (wires coming IN to junction)
- `FL2*` variants = **sources** (wires going OUT of junction)

**Implementation:**
```python
# For left pin (source): prefer FL2* variants
left_conn = find_connector_above_pin(left_pin_x, left_pin_y,
                                      prefer_as_source=True)

# For right pin (destination): prefer *2FL variants
right_conn = find_connector_above_pin(right_pin_x, right_pin_y,
                                       prefer_as_source=False)
```

**Why this matters:**
Without this rule, you get invalid chains like:
```
❌ MH3203D → MH2FL (stops)
❌ MH2FL → FTL2FL (MH2FL shouldn't be a source!)
```

With the rule:
```
✓ MH3203D → MH2FL (ends at junction)
✓ FL2MH → FTL2FL (continues from junction)
✓ FL2FTL → FTL5651 (continues from junction)
```

### 4. Pin Deduplication

Some wire specifications appear multiple times on the same row (e.g., overlapping dual-color wires). To avoid duplicate connections:

```python
# Create order-independent key for pin pair
pin_pair_key = tuple(sorted([
    (left_connector, left_pin, left_x, left_y),
    (right_connector, right_pin, right_x, right_y)
]))

if pin_pair_key not in seen_pin_pairs:
    connections.append(connection)
    seen_pin_pairs.add(pin_pair_key)
```

### 5. Unlabeled Splice Point Handling

**Edge Case:** Some diagrams contain splice point dots without accompanying labels (no SP001, SP023, etc.).

**Solution:** Automatically generate custom IDs for unlabeled splice dots.

**Implementation:**

```python
from models import IDGenerator

# 1. Initialize ID generator
id_generator = IDGenerator()

# 2. After mapping labeled splices to dots, identify unlabeled dots
text_elements = map_splice_positions_to_dots(text_elements, splice_dots)
text_elements = generate_ids_for_unlabeled_splices(text_elements, splice_dots, id_generator)

# 3. IDGenerator creates unique IDs: SP_CUSTOM_001, SP_CUSTOM_002, ...
```

**Detection Logic:**

```python
def generate_ids_for_unlabeled_splices(text_elements, dots, id_generator, max_distance=5):
    """Generate custom IDs for splice dots that don't have labels."""

    # Collect positions of all labeled splices
    labeled_positions = [(elem.x, elem.y) for elem in text_elements if is_splice_point(elem.content)]

    # Find dots without nearby labels (within 5 units)
    unlabeled_dots = []
    for dot_x, dot_y in dots:
        has_label = any(
            math.sqrt((dot_x - lx)**2 + (dot_y - ly)**2) < max_distance
            for lx, ly in labeled_positions
        )
        if not has_label:
            unlabeled_dots.append((dot_x, dot_y))

    # Generate custom IDs
    for dot_x, dot_y in unlabeled_dots:
        custom_id = id_generator.get_or_create_splice_id(dot_x, dot_y)
        text_elements.append(TextElement(custom_id, dot_x, dot_y))

    return text_elements
```

**Recognition:**

Custom splice IDs are recognized by `is_splice_point()`:

```python
def is_splice_point(text: str) -> bool:
    """Check if text is a splice point ID (SP001 or SP_CUSTOM_001)."""
    if re.match(r'^SP\d+$', text):  # Labeled: SP001
        return True
    if text.startswith('SP_CUSTOM_'):  # Custom: SP_CUSTOM_001
        return True
    return False
```

**Example:**

Edge case file: `test_cases/splicepoints-has-no-id.svg`
- Circuit diagram with 37 unique connectors
- Only 9 unlabeled splice dots (out of 12 total dots)
- Generated 9 custom IDs (SP_CUSTOM_001 to SP_CUSTOM_009)
- Result: 87 connections

**Why This Matters:**

- Some circuit diagrams omit splice point labels to reduce clutter
- Without auto-generation, connections to unlabeled splices would be lost
- Custom IDs ensure complete extraction while maintaining traceability

### 6. Shared Pin Connector Selection ("Between" Logic)

**Edge Case:** Multiple connectors positioned above the same physical pin.

**Problem:**
```
Wire: MH097 pin 7 ---[2.5,YE/BU]---> pin 1
Connectors above pin 1:
  - MH020 at X=317.8 (LEFT of pin, at end of yellow wire)
  - RRS100 at X=343.1 (RIGHT of pin, at start of red wire)
```

Without proper logic, algorithm picks **RRS100** (closest to pin, only 0.7 units away) instead of **MH020** (24.6 units away).

**Solution:** Prefer connectors **BETWEEN** wire spec and pin.

**Implementation:**

```python
def find_connector_above_pin(pin_x, pin_y, text_elements, prefer_as_source=False, source_x=None):
    """Find connector above pin, preferring those between source and pin."""

    # ... find all connectors above pin ...

    # CRITICAL: If source_x provided, prefer connectors BETWEEN source and pin
    if source_x is not None and not prefer_as_source:
        between_connectors = []
        other_connectors = []

        for conn in connectors_with_distance:
            cx = conn[4]  # connector X position

            # Check if connector is between source_x and pin_x
            if source_x < pin_x:
                is_between = source_x < cx < pin_x
            else:
                is_between = pin_x < cx < source_x

            if is_between:
                between_connectors.append(conn)
            else:
                other_connectors.append(conn)

        # Prioritize connectors between source and pin
        if between_connectors:
            connectors_with_distance = between_connectors + other_connectors

    # Return closest connector (now prioritizing "between" connectors)
    return connectors_with_distance[0]
```

**Example:**

Wire spec at X=243.9, pin at X=342.4:
- MH020 at X=317.8 → **BETWEEN** (243.9 < 317.8 < 342.4) ✓
- RRS100 at X=343.1 → **NOT BETWEEN** (343.1 > 342.4) ✗

Result: **MH020** is chosen (correct!)

**Why This Matters:**

- Shared pins are common at connector boundaries
- Picking the wrong connector breaks wire tracing
- "Between" logic ensures we follow the physical wire path

## SVG Structure Patterns

### Text Element Format

Adobe Illustrator exports text with transform matrices:

```xml
<text transform="matrix(1 0 0 1 237.3564 331.6939)" class="st3 st7">MH3202H</text>
```

The last two numbers in the matrix are the X and Y coordinates:
- X = 237.3564
- Y = 331.6939

### Connector ID Pattern

```regex
^[A-Z]{2,3}\d{1,5}[A-Z]{0,3}$
```

**Examples:**
- `MH3202C` - 2 letters + 4 digits + 1 letter
- `FL7210` - 2 letters + 4 digits
- `MH2FL` - 2 letters + 1 digit + 2 letters (junction)

**Exclusions:**
- `SP*` patterns (splices, not connectors)

### Wire Specification Pattern

```regex
^([\d.]+),([A-Z]{2}(?:/[A-Z]{2})?)$
```

**Examples:**
- `0.35,BN` - diameter 0.35mm, brown wire
- `0.5,GY/PU` - diameter 0.5mm, gray/purple wire
- `0.75,GN/RD` - diameter 0.75mm, green/red wire

## Connector Assignment Logic

```python
def find_connector_above_pin(pin_x, pin_y, text_elements, prefer_as_source=False):
    """
    Find the closest connector directly above a pin.

    Args:
        pin_x, pin_y: Pin coordinates
        prefer_as_source: If True, prefer FL2* for junctions
                         If False, prefer *2FL for junctions
    """
    connectors_above = []

    for elem in text_elements:
        if not is_connector_id(elem['content']):
            continue

        x_dist = abs(elem['x'] - pin_x)
        y_dist = pin_y - elem['y']

        # Connector must be above (positive y_dist) and horizontally aligned
        is_junction = ('2FL' in conn_id or 'FL2' in conn_id)
        max_x_dist = 100 if is_junction else 50

        if x_dist < max_x_dist and y_dist > 5:
            connectors_above.append((y_dist, elem['content'], elem['x'], elem['y']))

    if not connectors_above:
        return None

    # Get closest connector
    connectors_above.sort(key=lambda c: c[0])
    conn_id = connectors_above[0][1]

    # Handle junction preference
    if prefer_as_source:
        # Prefer FL2* pattern (source from junction)
        fl2_variants = [c for c in connectors_above if c[1].startswith('FL2')]
        if fl2_variants:
            conn_id = fl2_variants[0][1]
    else:
        # Prefer *2FL pattern (destination to junction)
        to_fl_variants = [c for c in connectors_above if c[1].endswith('2FL')]
        if to_fl_variants:
            conn_id = to_fl_variants[0][1]

    return conn_id
```

## Output Format

### Sorted Connection Table

Connections are sorted by:
1. **From connector ID** (alphabetically)
2. **From pin number** (numerically)

This makes it easy to verify all connections for each source connector.

### Grouped by Source Connector

Additional section groups connections by source connector with statistics:

```markdown
### MH3202C (6 connections)

| From Pin | To | To Pin | Wire DM | Color |
|----------|-----|--------|---------|-------|
| 25 | MH2FL | 8 | 0.35 | WH/RD |
| 26 | MH2FL | 9 | 0.35 | BU/BK |
...
```

## Lessons Learned

### What Didn't Work

1. **Boundary-based pin assignment** - Pins can be located past other connector labels
2. **Fixed distance thresholds** - Different connector types have different layouts
3. **"Closest connector wins"** - Doesn't account for junction semantics
4. **Large Y-axis tolerance (±20)** - Groups pins from different wire rows

### What Works

1. **Wire-centric algorithm** - Let wires dictate connections
2. **Tight Y-axis tolerance (±10)** - Ensures pins are on same horizontal line
3. **Junction direction rules** - `*2FL` as destinations, `FL2*` as sources
4. **Simple "connector above pin" lookup** - No spatial complexity
5. **Pin-pair deduplication** - Handles overlapping wire specifications

## Architecture (Refactored - Current Version)

The codebase has been refactored into a modular architecture for better maintainability and extensibility:

### Module Structure

```
extract_connections.py    # Main entry point
├── models.py            # Data structures (Connection, TextElement, WireSpec, etc.)
├── svg_parser.py        # SVG parsing utilities
├── connector_finder.py  # Connector identification and lookup logic
├── extractors.py        # Connection extraction classes
│   ├── HorizontalWireExtractor
│   ├── VerticalRoutingExtractor
│   └── GroundConnectionExtractor
└── output_formatter.py  # Output formatting and export
```

### Key Data Structures (models.py)

```python
@dataclass
class Connection:
    from_id: str
    from_pin: str
    to_id: str
    to_pin: str
    wire_dm: str
    wire_color: str

@dataclass
class TextElement:
    x: float
    y: float
    content: str

@dataclass
class WireSpec:
    x: float
    y: float
    diameter: str
    color: str

class IDGenerator:
    """For future: generates custom IDs for unnamed splice points and connectors"""
    def get_or_create_splice_id(x: float, y: float) -> str
    def get_or_create_connector_id(x: float, y: float) -> str
```

### SVG Parser (svg_parser.py)

- `parse_text_elements()` - Extract all text with coordinates
- `parse_splice_dots()` - Find splice point dot positions (circle paths)
- `parse_st17_polylines()` - Extract vertical routing polylines
- `parse_st17_paths()` - Extract ground connection paths
- `extract_wire_specs()` - Find wire specifications (diameter, color)
- `map_splice_positions_to_dots()` - Map SP* labels to actual dot positions
- `generate_ids_for_unlabeled_splices()` - Generate custom IDs (SP_CUSTOM_*) for dots without labels

### Connector Finder (connector_finder.py)

Core logic for finding connectors above pins with sophisticated junction handling:

```python
def find_connector_above_pin(
    pin_x: float,
    pin_y: float,
    text_elements: List[TextElement],
    prefer_as_source: bool = False,
    source_x: float = None
) -> Optional[Tuple[str, float, float]]:
    """
    Implements:
    - Euclidean distance sorting
    - Junction pair detection
    - "Between" logic: picks junction physically between source and destination
    - Type-specific selection:
      * MH junctions: pick closer to PIN (tightly packed)
      * FTL junctions: pick closer to SOURCE (spread out)
    """
```

### Extractors (extractors.py)

Three specialized extraction classes:

1. **HorizontalWireExtractor** - Wire-centric algorithm for horizontal wires
   - Groups connection points by horizontal line
   - Creates connections between ALL ADJACENT PAIRS
   - Handles junction selection with source_x context

2. **VerticalRoutingExtractor** - Processes st17 polylines
   - Finds nearest connection points to polyline endpoints
   - Handles multi-segment polylines with intermediate splices
   - Deduplicates before returning

3. **GroundConnectionExtractor** - Processes st17 paths
   - Finds connection points within 120 units of path arrow
   - Only creates connections involving ground connectors (with parentheses)
   - Prefers *2FL junction variants
   - Deduplicates before returning

### Critical: Ground Connection Distance Threshold

```python
# Ground connections use stricter distance filtering
if y_dist < 10 and x_dist < 120:  # 120 units, not 200
    # Connection point is valid
```

This prevents distant splice points from being incorrectly associated with ground arrows.

### Execution Flow

```python
# 0. Initialize ID generator for unlabeled splice points
id_generator = IDGenerator()

# 1. Parse all SVG elements
text_elements = parse_text_elements(svg_file)
splice_dots = parse_splice_dots(svg_file)
polylines = parse_st17_polylines(svg_file)
paths = parse_st17_paths(svg_file)

# 2. Map splice positions
text_elements = map_splice_positions_to_dots(text_elements, splice_dots)

# 2b. Generate custom IDs for unlabeled splice dots
text_elements = generate_ids_for_unlabeled_splices(text_elements, splice_dots, id_generator)

# 3. Extract wire specs
wire_specs = extract_wire_specs(text_elements)

# 4. Run extractors independently
horizontal_connections = HorizontalWireExtractor(text_elements, wire_specs).extract_connections()
vertical_connections = VerticalRoutingExtractor(polylines, text_elements).extract_connections()
ground_connections = GroundConnectionExtractor(paths, text_elements).extract_connections()

# 5. Combine (no global deduplication - each extractor deduplicates internally)
all_connections = horizontal_connections + vertical_connections + ground_connections

# 6. Export
export_to_file(all_connections, output_file)
```

## Usage

```bash
python extract_connections.py
```

**Input:** `sample-wire.svg` (Adobe Illustrator SVG export)

**Output:** `connections_output.md` (Markdown table of all connections)

## For AI Agents

If you're an AI agent working with similar SVG files, see **[wire-relation-prompt.md](wire-relation-prompt.md)** for a complete prompt that captures all the critical knowledge and rules from this project.

## Key Files

- `extract_connections.py` - Main entry point
- `models.py` - Data structures
- `svg_parser.py` - SVG parsing utilities
- `connector_finder.py` - Connector identification and lookup
- `extractors.py` - Connection extraction classes
- `output_formatter.py` - Output formatting
- `sample-wire.svg` - Example circuit diagram
- `connections_output.md` - Generated connection table
- `diagram.png` - Visual reference of the circuit

## Vertical Routing and Ground Connections

### 5. Vertical Routing Arrows (st17 Polylines)

Some connections use vertical routing arrows instead of horizontal wires with specs. These are encoded as `<polyline class="st17">` elements.

**Examples:**
- FL2FTL pin 8 → SP023
- FL7210B pin 3 → SP025
- FL7611 pins 1, 5, 9 → SP025

**Algorithm:**
```python
def extract_vertical_routing_connections(svg_file, text_elements):
    # Find all st17 polyline elements
    polylines = root.findall('.//polyline[@class="st17"]')

    for polyline in polylines:
        # Parse points: "x1,y1 x2,y2 x3,y3 ..."
        points = polyline.get('points').split()
        start = points[0]  # First point
        end = points[-1]   # Last point

        # Find nearest pin/splice to each endpoint (within 100 units)
        endpoint1 = find_nearest_connection_point(start_x, start_y)
        endpoint2 = find_nearest_connection_point(end_x, end_y)

        # Determine direction: splice points are ALWAYS destinations
        if is_splice_point(endpoint1):
            source, dest = endpoint2, endpoint1
        elif is_splice_point(endpoint2):
            source, dest = endpoint1, endpoint2
        else:
            # Use Y-coordinate: higher up = destination
            source, dest = (endpoint1, endpoint2) if start_y > end_y else (endpoint2, endpoint1)
```

**Multi-Segment Polylines:**

Some polylines connect multiple pins to one splice via intermediate points:

```python
# Example: 5-point polyline connecting FL7611 pins 1 and 9 to SP025
points = "718.4,678.9 800.6,678.9 800.6,384.4 781,653 718,653"

# Check if both endpoints are pins and there's a splice in the middle
if len(points) > 2 and both_endpoints_are_pins:
    for intermediate_point in middle_points:
        intermediate = find_nearest_connection_point(px, py)
        if is_splice_point(intermediate):
            # Create TWO connections:
            # 1. endpoint1 → splice
            # 2. endpoint2 → splice
            break
```

### 6. Ground Connections (st17 Paths)

Ground connections (e.g., to `G22B(m)`) use `<path class="st17">` elements as arrowheads.

**Ground Connector Pattern:**
```regex
^[A-Z]+\d+[A-Z]*\([a-z]\)$
```

**Examples:** `G22B(m)`, `G05(z)`

**Algorithm:**
```python
def extract_ground_connections(svg_file, text_elements):
    # Find all st17 path elements
    paths = root.findall('.//path[@class="st17"]')

    for path in paths:
        # Parse M command to get arrow location
        d = path.get('d')  # e.g., "M977.9,384.4c-29.2,0,-191.9,0,-217.4,0..."
        path_x, path_y = extract_M_coordinates(d)

        # Find connection points on same horizontal line
        # Within ±10 Y units AND ±200 X units of arrow
        connection_points = []
        for elem in text_elements:
            y_dist = abs(elem['y'] - path_y)
            x_dist = abs(elem['x'] - path_x)

            if y_dist < 10 and x_dist < 200:
                if is_pin(elem):
                    # For ground connections, prefer *2FL junction variant
                    connector = find_connector_above_pin_prefer_2FL(elem)
                    connection_points.append((elem['x'], connector, pin, elem['y']))
                elif is_ground_connector(elem):
                    connection_points.append((elem['x'], elem['content'], '', elem['y']))

        # Only create connection if one endpoint is a ground connector
        # This filters out regular routing already handled by horizontal wires
        if has_ground_connector(connection_points):
            # Find pair with maximum X distance
            # Create connection: pin → ground
```

**Critical: Junction Connector Selection for Ground**

When a pin is shared by junction connectors (e.g., FL2MH and MH2FL both above pin 73), ground connections prefer the `*2FL` variant:

```python
# For ground connections at junction pins
connectors_above = find_all_connectors_above_pin(pin_x, pin_y)

# Prefer *2FL pattern (MH2FL, FTL2FL) for ground wires
to_fl_variants = [c for c in connectors_above if c.endswith('2FL')]
if to_fl_variants:
    return to_fl_variants[0]  # e.g., MH2FL instead of FL2MH
```

**Example:** MH2FL pin 73 → G22B(m)

**Why:** Ground wires come from the destination/input side of junction connectors.

### Connection Type Summary

| Type | Element | Example | Wire Specs |
|------|---------|---------|------------|
| Horizontal wires | Text: wire specs | FL2MH pin 1 → FL7210 pin 4 | 0.35,GY/PU |
| Vertical routing | `<polyline class="st17">` | FL7210B pin 3 → SP025 | None |
| Ground connections | `<path class="st17">` | MH2FL pin 73 → G22B(m) | None |

**Final Statistics:**
- 48 horizontal wire connections (with wire specs)
- 5 vertical polyline routing connections
- 1 ground path connection
- **Total: 54 connections**

## Optional Exclusion Configuration

### Reference-Only Pins

Some circuit diagrams contain reference sections showing connector pins that point to external diagrams. These pins should not create connections within the current diagram.

**Solution:** Create an optional `exclusions_config.json` file to specify pins to exclude:

```json
{
  "description": "Optional exclusion configuration for reference-only pins",
  "exclusions": [
    {
      "connector_id": "RRS111",
      "pin": "22",
      "reason": "Reference connection to external diagram"
    },
    {
      "connector_id": "RRS111",
      "pin": "23",
      "reason": "Reference connection to external diagram"
    }
  ],
  "notes": [
    "Only exclude pins that ONLY connect to text labels or external references",
    "If a pin has valid connections to connectors/splices, keep those connections"
  ]
}
```

### Implementation

The extractor automatically loads `exclusions_config.json` if present:

```python
# Load exclusions
exclusions = load_exclusions('exclusions_config.json')

# Apply after extraction and deduplication
all_connections = apply_exclusions(all_connections, exclusions)
```

### Smart Filtering Logic

**Key Rule:** Exclusions are applied at the connection level, not the pin level.

- If a pin is in the exclusion list AND connects to a valid connector/splice → connection is excluded
- If a pin has multiple connections, ALL connections involving that pin are excluded
- The exclusion prevents false connections to text labels or reference sections

**Example:**

```
RRS111 pin 22 → RRS114 pin 2  ❌ Excluded (RRS111,22 in exclusion list)
RRS111 pin 23 → GND1 pin 13   ❌ Excluded (RRS111,23 in exclusion list + GND1 is a label)
SP113 → RR622 pin 26          ✓ Kept (SP113 not in exclusion list, valid connection)
```

### When to Use Exclusions

Use exclusion configuration for:
1. **Reference sections** with arrows pointing to external diagrams
2. **Connector detail boxes** showing internal wiring that shouldn't connect
3. **Description labels** inside dashed connector frames (e.g., GND1, GND2)

Do NOT use exclusions for:
- Splice points that have valid connections to other connectors
- Pins that connect to actual ground connectors (e.g., G22_B(m))
- Any pin that has legitimate wire connections in the diagram

## Future Improvements

- Support for other SVG export tools (Inkscape, AutoCAD, etc.)
- Configurable Y-axis tolerance based on diagram scale
- Automatic detection of wire specs near vertical routing paths
- Validation against physical connector pin counts
- Export to CSV, JSON, or Excel formats
- we are in windows command (windows 11 pro), we have git bash, github cli and other cli installed