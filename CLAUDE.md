# Circuit Diagram SVG Connection Extractor

## Project Overview

This tool extracts wire connections from circuit diagram SVG files generated by Adobe Illustrator. It parses connector IDs, pin numbers, wire specifications (diameter and color), and produces a complete connection table.

## Core Algorithm: Wire-Centric Approach

### The Key Insight

Instead of trying to assign pins to connectors using spatial boundaries, we **start from the wires** and work outward:

1. **Find all wire specifications** (e.g., "0.35,GY/PU")
2. **For each wire, find the pins on both ends** of the horizontal line
3. **For each pin, look up which connector is directly above it**

This approach avoids the complexity of:
- Determining which pins "belong" to which connector when pins are far below labels
- Handling multiple connector instances of the same type
- Dealing with interleaved connectors of different types

### Algorithm Steps

```
For each wire specification in the SVG:
    1. Find all pins on the same horizontal line (±10 Y units)
    2. Identify the leftmost pin right of wire spec (source)
    3. Identify the rightmost pin left of wire spec (destination)
    4. For left pin: find closest connector above (prefer FL2* variants for junctions)
    5. For right pin: find closest connector above (prefer *2FL variants for junctions)
    6. Create connection: (left_connector, left_pin) → (right_connector, right_pin)
    7. Skip if this pin-pair already processed (deduplication)
```

## Critical Design Decisions

### 1. Wire-Centric vs Pin-Centric

**❌ Pin-Centric (Failed Approach):**
- Try to assign pins to connectors based on spatial proximity
- Problem: Pins can be located far below their connector, past other connector labels
- Problem: Boundary-based approaches fail when connectors are interleaved

**✓ Wire-Centric (Successful Approach):**
- Let the wires dictate the connections
- Simple rule: find the connector directly above each pin
- No boundaries, no complex spatial logic

### 2. Y-Axis Tolerance: ±10 Units

**Why this matters:**
- Wire specifications and pins must be on the same horizontal row
- Too large (±20): Groups pins from different rows → wrong connections
- Too small (±5): Misses valid pins due to SVG rendering variations
- **±10 units** is the sweet spot for Adobe Illustrator SVG exports

**Example of the problem at ±20:**
```
Pin 25 at Y=611.17  }  24.8 units apart
Pin 8  at Y=586.38  }  ← Both matched to wire at Y=604.9
→ Algorithm picks pin 8 (closer horizontally) instead of pin 25
```

### 3. Junction Connector Handling

Circuit diagrams use bidirectional junction connectors that share pins:

**Junction Pairs:**
- `MH2FL` ↔ `FL2MH` (Main to Front-Left junction)
- `FTL2FL` ↔ `FL2FTL` (Front-To-Left junction)

**Rule:**
- `*2FL` variants = **destinations** (wires coming IN to junction)
- `FL2*` variants = **sources** (wires going OUT of junction)

**Implementation:**
```python
# For left pin (source): prefer FL2* variants
left_conn = find_connector_above_pin(left_pin_x, left_pin_y,
                                      prefer_as_source=True)

# For right pin (destination): prefer *2FL variants
right_conn = find_connector_above_pin(right_pin_x, right_pin_y,
                                       prefer_as_source=False)
```

**Why this matters:**
Without this rule, you get invalid chains like:
```
❌ MH3203D → MH2FL (stops)
❌ MH2FL → FTL2FL (MH2FL shouldn't be a source!)
```

With the rule:
```
✓ MH3203D → MH2FL (ends at junction)
✓ FL2MH → FTL2FL (continues from junction)
✓ FL2FTL → FTL5651 (continues from junction)
```

### 4. Pin Deduplication

Some wire specifications appear multiple times on the same row (e.g., overlapping dual-color wires). To avoid duplicate connections:

```python
# Create order-independent key for pin pair
pin_pair_key = tuple(sorted([
    (left_connector, left_pin, left_x, left_y),
    (right_connector, right_pin, right_x, right_y)
]))

if pin_pair_key not in seen_pin_pairs:
    connections.append(connection)
    seen_pin_pairs.add(pin_pair_key)
```

### 5. Unlabeled Splice Point Handling

**Edge Case:** Some diagrams contain splice point dots without accompanying labels (no SP001, SP023, etc.).

**Solution:** Automatically generate custom IDs for unlabeled splice dots.

**Implementation:**

```python
from models import IDGenerator

# 1. Initialize ID generator
id_generator = IDGenerator()

# 2. After mapping labeled splices to dots, identify unlabeled dots
text_elements = map_splice_positions_to_dots(text_elements, splice_dots)
text_elements = generate_ids_for_unlabeled_splices(text_elements, splice_dots, id_generator)

# 3. IDGenerator creates unique IDs: SP_CUSTOM_001, SP_CUSTOM_002, ...
```

**Detection Logic:**

```python
def generate_ids_for_unlabeled_splices(text_elements, dots, id_generator, max_distance=5):
    """Generate custom IDs for splice dots that don't have labels."""

    # Collect positions of all labeled splices
    labeled_positions = [(elem.x, elem.y) for elem in text_elements if is_splice_point(elem.content)]

    # Find dots without nearby labels (within 5 units)
    unlabeled_dots = []
    for dot_x, dot_y in dots:
        has_label = any(
            math.sqrt((dot_x - lx)**2 + (dot_y - ly)**2) < max_distance
            for lx, ly in labeled_positions
        )
        if not has_label:
            unlabeled_dots.append((dot_x, dot_y))

    # Generate custom IDs
    for dot_x, dot_y in unlabeled_dots:
        custom_id = id_generator.get_or_create_splice_id(dot_x, dot_y)
        text_elements.append(TextElement(custom_id, dot_x, dot_y))

    return text_elements
```

**Recognition:**

Custom splice IDs are recognized by `is_splice_point()`:

```python
def is_splice_point(text: str) -> bool:
    """Check if text is a splice point ID (SP001 or SP_CUSTOM_001)."""
    if re.match(r'^SP\d+$', text):  # Labeled: SP001
        return True
    if text.startswith('SP_CUSTOM_'):  # Custom: SP_CUSTOM_001
        return True
    return False
```

**Example:**

Edge case file: `test_cases/splicepoints-has-no-id.svg`
- Circuit diagram with 37 unique connectors
- Only 9 unlabeled splice dots (out of 12 total dots)
- Generated 9 custom IDs (SP_CUSTOM_001 to SP_CUSTOM_009)
- Result: 87 connections

**Why This Matters:**

- Some circuit diagrams omit splice point labels to reduce clutter
- Without auto-generation, connections to unlabeled splices would be lost
- Custom IDs ensure complete extraction while maintaining traceability

### 6. Shared Pin Connector Selection ("Between" Logic)

**Edge Case:** Multiple connectors positioned above the same physical pin.

**Problem:**
```
Wire: MH097 pin 7 ---[2.5,YE/BU]---> pin 1
Connectors above pin 1:
  - MH020 at X=317.8 (LEFT of pin, at end of yellow wire)
  - RRS100 at X=343.1 (RIGHT of pin, at start of red wire)
```

Without proper logic, algorithm picks **RRS100** (closest to pin, only 0.7 units away) instead of **MH020** (24.6 units away).

**Solution:** Prefer connectors **BETWEEN** wire spec and pin.

**Implementation:**

```python
def find_connector_above_pin(pin_x, pin_y, text_elements, prefer_as_source=False, source_x=None):
    """Find connector above pin, preferring those between source and pin."""

    # ... find all connectors above pin ...

    # CRITICAL: If source_x provided, prefer connectors BETWEEN source and pin
    if source_x is not None and not prefer_as_source:
        between_connectors = []
        other_connectors = []

        for conn in connectors_with_distance:
            cx = conn[4]  # connector X position

            # Check if connector is between source_x and pin_x
            if source_x < pin_x:
                is_between = source_x < cx < pin_x
            else:
                is_between = pin_x < cx < source_x

            if is_between:
                between_connectors.append(conn)
            else:
                other_connectors.append(conn)

        # Prioritize connectors between source and pin
        if between_connectors:
            connectors_with_distance = between_connectors + other_connectors

    # Return closest connector (now prioritizing "between" connectors)
    return connectors_with_distance[0]
```

**Example:**

Wire spec at X=243.9, pin at X=342.4:
- MH020 at X=317.8 → **BETWEEN** (243.9 < 317.8 < 342.4) ✓
- RRS100 at X=343.1 → **NOT BETWEEN** (343.1 > 342.4) ✗

Result: **MH020** is chosen (correct!)

**Why This Matters:**

- Shared pins are common at connector boundaries
- Picking the wrong connector breaks wire tracing
- "Between" logic ensures we follow the physical wire path

**Critical Configuration:**

The "between" logic has a Y-distance threshold to prevent distant connectors from being prioritized just because they happen to be between in X:

```python
# Only prioritize "between" connectors if they're reasonably close in Y
# Use a threshold of 60 Y-units as "reasonable" vertical distance
if is_between and y_dist < 60:
    between_connectors.append(conn)
```

Initially set to 50 units, this was increased to 60 units after discovering that valid "between" connectors at Y-distance=52.4 were being excluded.

### 6a. Wire Spec Selection for Groups with Multiple Y Positions

**Edge Case:** Multiple wire specs grouped together (round(Y/10)*10) can have significantly different Y positions, causing connection points to be missed.

**Problem:**
```
Group 110 contains 3 wire specs:
  - 1.5,YE/GN at Y=106.7
  - 2.5,RD/WH at Y=111.9
  - 2.5,YE at Y=112.1

If algorithm uses specs_on_line[0].y (106.7) to find pins within ±10:
  - Matches pins at Y=112-116 ✓
  - MISSES pins at Y=118 ✗ (118 > 106.7+10)

Result: Valid connections involving pins at Y=118 are not created!
```

**Root Cause:** The original implementation used `specs_on_line[0].y` as the reference Y position for finding connection points. When the first spec in a group had a significantly different Y than other specs, pins near the other specs would not be matched.

**Solution:** Check if connection points are within ±10 of **ANY** spec in the group, not just the first one.

**Implementation:**

```python
# BEFORE (WRONG):
for elem in self.text_elements:
    if abs(elem.y - specs_on_line[0].y) < 10:  # Only checks first spec!
        if elem.content.isdigit() or is_splice_point(elem.content):
            connection_points.append(elem)

# AFTER (CORRECT):
for elem in self.text_elements:
    if elem.content.isdigit() or is_splice_point(elem.content):
        for spec in specs_on_line:  # Check ALL specs in group
            if abs(elem.y - spec.y) < 10:
                connection_points.append(elem)
                break  # Don't add same element multiple times
```

**Wire Spec Selection Logic:**

Once all connection points are found, select the wire spec **closest in Y-distance to the average pin position**:

```python
# Calculate average Y position of all connection points
avg_pin_y = sum(p.y for p in connection_points) / len(connection_points)

# Select the wire spec closest in Y to the average
wire_spec = min(specs_on_line, key=lambda s: abs(s.y - avg_pin_y))
```

This implements the principle that **wire specs are positioned directly above the wires they describe**.

**Example:**

```
Group 110 specs:
  - 1.5,YE/GN at Y=106.7
  - 2.5,RD/WH at Y=111.9
  - 2.5,YE at Y=112.1

Connection points found: pins at Y=112.2, 112.3, 112.5, 117.9, 118.2, 118.4
Average pin Y: 115.2

Y-distances from average:
  - 1.5,YE/GN: |106.7 - 115.2| = 8.5 units
  - 2.5,RD/WH: |111.9 - 115.2| = 3.3 units
  - 2.5,YE: |112.1 - 115.2| = 3.1 units ✓ SELECTED

Result: Connections use 2.5,YE (the spec closest to the pins)
```

**Why This Matters:**

- Prevents missing valid connections when wire specs have varying Y positions
- Ensures the correct wire spec is used (closest to actual pins, not arbitrary first spec)
- Respects the physical layout principle that specs are positioned above their wires

**Real-World Impact:**

This fix resolved MH097,12 → MH020,17 showing wrong wire spec (1.5,RD/YE instead of 2.5,YE) and discovered a previously missed valid connection (RRS113,11 → RRS112,4 with 2.5,YE).

### 7. L-Shaped Routing Wires (st3/st4 Path Filtering)

**Edge Case:** Some circuit diagrams use L-shaped routing wires (vertical + horizontal segments) encoded as `<path class="st3">` or `<path class="st4">` elements.

**Problem:**
```
st3 paths can represent TWO types of connections:
1. TRUE L-shaped wires (vertical routing with 'v' or 'V' commands)
2. Horizontal-only wires (using 'c' curve commands without vertical segments)

Type 2 creates DUPLICATE connections already captured by wire specs!
```

**Example:**

Horizontal wire with spec at Y=742.1:
```xml
<!-- Horizontal-only st3 path (DUPLICATE) -->
<path class="st3" d="M401.3,742.1c285.8,0,142.8,0,149.4,0"/>
<!-- Wire spec already captures this connection -->
<text>0.35,BK</text>
```

L-shaped wire for RRT15,3 → SP323:
```xml
<!-- TRUE L-shaped st3 path (UNIQUE connection) -->
<path class="st3" d="M624.3,796.2c76.4,0,52,0,71.8,0v-54.2"/>
<!-- 'v-54.2' indicates vertical segment -->
```

**Solution:** Smart filtering - only parse st3/st4 paths with vertical segments.

**Implementation:**

```python
def parse_routing_paths(svg_file: str, only_l_shaped: bool = True) -> List[str]:
    """
    Parse routing path elements, optionally filtering for L-shaped paths.

    Args:
        svg_file: Path to SVG file
        only_l_shaped: If True, only return paths with vertical segments (v/V commands)
                      to filter out horizontal-only paths that duplicate wire specs
    """
    paths = []

    for path in root.iter('{http://www.w3.org/2000/svg}path'):
        cls = path.get('class', '')
        if cls in ['st3', 'st4']:
            d = path.get('d', '').strip()
            if d:
                # Filter: only include L-shaped paths (those with vertical segments)
                if only_l_shaped:
                    if 'v' in d or 'V' in d:  # Check for vertical commands
                        paths.append(d)
                else:
                    paths.append(d)

    return paths
```

**Usage:**

```python
# In extract_connections.py
routing_paths = parse_routing_paths(svg_file, only_l_shaped=True)  # Only TRUE L-shaped wires
```

**Why This Matters:**

- Enabling all st3/st4 paths creates massive duplicates (breaks test cases)
- Smart filtering adds ONLY unique L-shaped connections
- sample-wire.svg remains unchanged (no st3 paths with vertical segments)
- test_cases adds RRT15,3 → SP323 connection without duplicates

**SVG Path Commands Reference:**
- `M x,y` - Move to absolute position
- `c dx1,dy1,dx2,dy2,dx,dy` - Relative cubic Bezier curve (horizontal wire)
- `v dy` - Relative vertical line (LOWERCASE = relative)
- `V y` - Absolute vertical line (UPPERCASE = absolute)
- `h dx` - Relative horizontal line
- `H x` - Absolute horizontal line

### 8. Rectangular Polyline Routing Wires

**Edge Case:** Some circuit diagrams use rectangular polylines (4-point H-V-H pattern) to connect components at different vertical levels.

**Pattern Recognition:**
```python
# A rectangular polyline has 4 points forming 3 sides: H-V-H
# Structure: point1 → point2 → point3 → point4
is_rectangular = (
    len(path_points) == 4 and
    abs(path_points[0][1] - path_points[1][1]) < 5 and  # First segment horizontal
    abs(path_points[1][0] - path_points[2][0]) < 5 and  # Second segment vertical
    abs(path_points[2][1] - path_points[3][1]) < 5      # Third segment horizontal
)
```

**Examples:**
- UH07 ↔ UH08 (orange wire forming rectangle)
- SR02 ↔ SR03 (multiple colored wires, each forming rectangle)
- MAIN14,1 → G203B(m) (4.0, BK ground connection via rectangular path)

**Critical Implementation Details:**

**1. Corner Endpoint Detection (15-unit threshold):**

```python
# Find connectors/pins near all 4 corners
for px, py in path_points:
    min_dist = 15  # Tight threshold to match only true endpoints

    for elem in text_elements:
        dist = math.sqrt((elem.x - px)**2 + (elem.y - py)**2)
        if dist < min_dist:
            if is_connector_id(elem.content) or elem.content.isdigit() or is_splice_point(elem.content):
                nearest_connector = elem
```

**Why 15 units:**
- Valid endpoints: UH07 (10.6), UH08 (10.1), G203B(m) (12.7), pins (5-8 units)
- Excludes incidental labels: MAIN14 at 15.8 units (too far), G202(m) at 50 units (way too far)

**2. Wire Spec Selection (Longest Horizontal Segment):**

Rectangular polylines have multiple horizontal segments. The wire spec is positioned on the **longest** segment (main wire), not the short entry segment.

```python
def _find_wire_spec_for_rectangular_polyline(path_points):
    """Find wire spec on the longest horizontal segment."""

    # Find all horizontal segments and their lengths
    horizontal_segments = []
    for i in range(len(path_points) - 1):
        x1, y1 = path_points[i]
        x2, y2 = path_points[i + 1]
        if abs(y2 - y1) < 5:  # Horizontal
            length = abs(x2 - x1)
            horizontal_segments.append((length, x1, y1, x2, y2))

    # Sort by length (longest first)
    horizontal_segments.sort(reverse=True)

    # Find wire spec on longest segment
    _, x1, y1, x2, y2 = horizontal_segments[0]
    # ... search for spec between x1 and x2, within ±15 Y units
```

**Example:**

MAIN14,1 → G203B(m) polyline:
- Short segment at Y=204.9 with "2.5, BK" (SR01-SR02 wire)
- **Long segment at Y=155.4 with "4.0, BK"** ← Selected!

**3. Wire Spec Conflict Resolution (Shared Pin Disambiguation):**

When a pin has multiple connectors above it and already has a horizontal wire with a different wire spec, select the alternative connector.

```python
# Pin 1 at (649.71, 207.07) has TWO connectors above:
# - SR01 (16.29 units away) - already has horizontal wire with "2.5, BK"
# - MAIN14 (26.55 units away)

# Check if primary connector (SR01) already has a horizontal wire
existing_wire_spec = None
for conn in horizontal_connections:
    if conn.from_id == primary_connector and conn.from_pin == pin_num:
        existing_wire_spec = (conn.wire_dm, conn.wire_color)
        break

# Get polyline's wire spec (4.0, BK from longest segment)
polyline_wire_spec = self._find_wire_spec_for_rectangular_polyline(path_points)

# If specs conflict, use alternative connector
if existing_wire_spec and existing_wire_spec != polyline_wire_spec:
    all_connectors = find_all_connectors_above_pin(pin_x, pin_y, text_elements)
    for _, alt_conn_id, alt_x, alt_y in all_connectors:
        if alt_conn_id != primary_connector:
            conn_result = (alt_conn_id, alt_x, alt_y)
            break
```

**Result:** Pin 1 correctly assigned to MAIN14 (not SR01), creating connection MAIN14,1 → G203B(m) with wire spec 4.0, BK.

**Why This Matters:**

- Pins can have multiple connections: ONE horizontal wire + multiple vertical routing paths
- But each wire spec must match the physical wire (different specs = different connectors)
- This disambiguation ensures correct connector assignment when pins are shared

**Key Rule:**

✅ **ALLOWED:** Pin has one horizontal wire (2.5, BK to SR02) + one vertical routing wire (4.0, BK to G203B(m))
❌ **FORBIDDEN:** Pin connects to two different destinations with the SAME wire spec (duplicate horizontal wires)

### 9. Pass-Through Splice Point Filtering

**Edge Case:** Splice points that act as "pass-throughs" for horizontal wires.

**Problem:**
```
Splice Point Anatomy:
    SP113 (829.9, 732.2)
      ↑            ↑
  Left wire   Right wire
(from RR626)  (to RR622)

When a splice has horizontal wires on BOTH sides, it's a "pass-through".
Routing connections (polylines) should NOT connect two pass-through splices!
```

**Example of False Connection:**

```
Horizontal wires at Y=732.2:
  RR626,24 → SP113 (horizontal wire with 0.35,BK spec)
  SP113 → RR622,26 (horizontal wire with 0.35,BK spec)

  MH622,26 → SP184 (horizontal wire with 0.35,BK spec)
  SP184 → MH630,18 (horizontal wire with 0.35,BK spec)

Polyline: 974.8,742.1 → 974.8,777.5 → 822.1,777.5
  Nearest to start: SP184 (10.9 units)
  Nearest to end: SP113 (46.0 units)

❌ Algorithm creates: SP184 → SP113
   This is WRONG! Both are pass-throughs with dedicated horizontal wires.
```

**Solution:** Track pass-through splices and filter routing connections between them.

**Implementation:**

```python
class VerticalRoutingExtractor:
    def __init__(self, polylines, routing_paths, text_elements, horizontal_connections):
        # ... existing code ...

        # Track splice points with horizontal connections on BOTH sides
        splice_incoming = {}  # splice_id -> count of incoming horizontal wires
        splice_outgoing = {}  # splice_id -> count of outgoing horizontal wires

        for conn in horizontal_connections:
            if is_splice_point(conn.from_id):
                splice_outgoing[conn.from_id] = splice_outgoing.get(conn.from_id, 0) + 1
            if is_splice_point(conn.to_id):
                splice_incoming[conn.to_id] = splice_incoming.get(conn.to_id, 0) + 1

        # Identify bidirectional pass-through splices
        self.passthrough_splices = set()
        for splice_id in set(splice_incoming.keys()) | set(splice_outgoing.keys()):
            if splice_incoming.get(splice_id, 0) >= 1 and splice_outgoing.get(splice_id, 0) >= 1:
                self.passthrough_splices.add(splice_id)

    def extract_connections(self):
        # ... process polylines ...

        # Filter: Skip routing connections between two pass-through splices
        if (source_endpoint.connector_id in self.passthrough_splices and
            dest_endpoint.connector_id in self.passthrough_splices):
            continue  # Don't create connection

        # But ALLOW connections from pass-through splices to pins
        # Example: SP025 → FL7611,9 is valid (SP025 is pass-through, FL7611 is a pin)
```

**Multi-Segment Polyline Filtering:**

For polylines with intermediate splices (e.g., `pin1 → splice → pin2`):

```python
# In VerticalRoutingExtractor (extractors/vertical_routing_extractor.py)
if splice_found:
    # Connection 1: endpoint1 → splice
    if not (endpoint1.connector_id in self.passthrough_splices and
            splice_found.connector_id in self.passthrough_splices):
        connections.append(Connection(...))

    # Connection 2: splice → endpoint2
    if not (splice_found.connector_id in self.passthrough_splices and
            endpoint2.connector_id in self.passthrough_splices):
        connections.append(Connection(...))
```

**Why This Matters:**

- Pass-through splices are common in automotive circuit diagrams
- Without filtering, false connections create invalid wire traces
- Filtering preserves legitimate connections (splice → pin, pin → splice)
- Only blocks splice → splice connections for pass-through nodes

**Examples:**

```
✓ ALLOWED:
  - SP025 → FL7611,9 (pass-through splice to pin)
  - RRT15,3 → SP323 (pin to pass-through splice)

❌ BLOCKED:
  - SP184 → SP113 (both are pass-through splices)
  - SP305 → SP323 (both are pass-through splices)
```

## SVG Structure Patterns

### Text Element Format

Adobe Illustrator exports text with transform matrices:

```xml
<text transform="matrix(1 0 0 1 237.3564 331.6939)" class="st3 st7">MH3202H</text>
```

The last two numbers in the matrix are the X and Y coordinates:
- X = 237.3564
- Y = 331.6939

### Connector ID Pattern

```regex
^[A-Z]{2,3}\d{1,5}[A-Z]{0,3}$
```

**Examples:**
- `MH3202C` - 2 letters + 4 digits + 1 letter
- `FL7210` - 2 letters + 4 digits
- `MH2FL` - 2 letters + 1 digit + 2 letters (junction)

**Exclusions:**
- `SP*` patterns (splices, not connectors)

### Wire Specification Pattern

```regex
^([\d.]+),([A-Z]{2}(?:/[A-Z]{2})?)$
```

**Examples:**
- `0.35,BN` - diameter 0.35mm, brown wire
- `0.5,GY/PU` - diameter 0.5mm, gray/purple wire
- `0.75,GN/RD` - diameter 0.75mm, green/red wire

## Connector Assignment Logic

```python
def find_connector_above_pin(pin_x, pin_y, text_elements, prefer_as_source=False):
    """
    Find the closest connector directly above a pin.

    Args:
        pin_x, pin_y: Pin coordinates
        prefer_as_source: If True, prefer FL2* for junctions
                         If False, prefer *2FL for junctions
    """
    connectors_above = []

    for elem in text_elements:
        if not is_connector_id(elem['content']):
            continue

        x_dist = abs(elem['x'] - pin_x)
        y_dist = pin_y - elem['y']

        # Connector must be above (positive y_dist) and horizontally aligned
        is_junction = ('2FL' in conn_id or 'FL2' in conn_id)
        max_x_dist = 100 if is_junction else 50

        if x_dist < max_x_dist and y_dist > 5:
            connectors_above.append((y_dist, elem['content'], elem['x'], elem['y']))

    if not connectors_above:
        return None

    # Get closest connector
    connectors_above.sort(key=lambda c: c[0])
    conn_id = connectors_above[0][1]

    # Handle junction preference
    if prefer_as_source:
        # Prefer FL2* pattern (source from junction)
        fl2_variants = [c for c in connectors_above if c[1].startswith('FL2')]
        if fl2_variants:
            conn_id = fl2_variants[0][1]
    else:
        # Prefer *2FL pattern (destination to junction)
        to_fl_variants = [c for c in connectors_above if c[1].endswith('2FL')]
        if to_fl_variants:
            conn_id = to_fl_variants[0][1]

    return conn_id
```

## Output Format

### Sorted Connection Table

Connections are sorted by:
1. **From connector ID** (alphabetically)
2. **From pin number** (numerically)

This makes it easy to verify all connections for each source connector.

### Grouped by Source Connector

Additional section groups connections by source connector with statistics:

```markdown
### MH3202C (6 connections)

| From Pin | To | To Pin | Wire DM | Color |
|----------|-----|--------|---------|-------|
| 25 | MH2FL | 8 | 0.35 | WH/RD |
| 26 | MH2FL | 9 | 0.35 | BU/BK |
...
```

## Lessons Learned

### What Didn't Work

1. **Boundary-based pin assignment** - Pins can be located past other connector labels
2. **Fixed distance thresholds** - Different connector types have different layouts
3. **"Closest connector wins"** - Doesn't account for junction semantics
4. **Large Y-axis tolerance (±20)** - Groups pins from different wire rows
5. **Enabling all st3/st4 paths** - Creates massive duplicates of horizontal wires
6. **Ignoring pass-through splices** - Creates false connections between splice points with horizontal wires

### What Works

1. **Wire-centric algorithm** - Let wires dictate connections
2. **Tight Y-axis tolerance (±10)** - Ensures pins are on same horizontal line
3. **Junction direction rules** - `*2FL` as destinations, `FL2*` as sources
4. **Simple "connector above pin" lookup** - No spatial complexity
5. **Pin-pair deduplication** - Handles overlapping wire specifications
6. **Smart L-shaped path filtering** - Only parse st3/st4 paths with vertical segments ('v' or 'V' commands)
7. **Pass-through splice detection** - Track splices with horizontal wires on both sides, filter routing connections between them
8. **Modular extractor architecture** - Split 2175-line monolith into focused modules with inheritance for shared utilities

## Architecture (Refactored - Current Version)

The codebase has been refactored into a modular architecture for better maintainability and extensibility:

### Module Structure

```
extract_connections.py          # Main entry point
├── models.py                  # Data structures (Connection, TextElement, WireSpec, etc.)
├── svg_parser.py              # SVG parsing utilities
├── connector_finder.py        # Connector identification and lookup logic
├── output_formatter.py        # Output formatting and export
└── extractors/                # Connection extraction package (modular)
    ├── __init__.py           # Package initialization, exports all extractors
    ├── base_extractor.py     # Base class with shared utilities
    ├── horizontal_wire_extractor.py
    ├── horizontal_colored_wire_extractor.py
    ├── vertical_routing_extractor.py
    ├── ground_connection_extractor.py
    ├── long_routing_connection_extractor.py
    └── grid_wire_extractor.py
```

**Benefits of Modular Architecture:**
- **Clarity**: Each extractor has its own file (~150-400 lines vs 2175-line monolith)
- **Maintainability**: Changes to one extractor don't affect others
- **Testability**: Individual extractors can be tested in isolation
- **Reusability**: BaseExtractor shares common utilities (wire spec detection, deduplication)
- **Scalability**: New extractor types can be added without modifying existing code

### Key Data Structures (models.py)

```python
@dataclass
class Connection:
    from_id: str
    from_pin: str
    to_id: str
    to_pin: str
    wire_dm: str
    wire_color: str

@dataclass
class TextElement:
    x: float
    y: float
    content: str

@dataclass
class WireSpec:
    x: float
    y: float
    diameter: str
    color: str

class IDGenerator:
    """For future: generates custom IDs for unnamed splice points and connectors"""
    def get_or_create_splice_id(x: float, y: float) -> str
    def get_or_create_connector_id(x: float, y: float) -> str
```

### SVG Parser (svg_parser.py)

- `parse_text_elements()` - Extract all text with coordinates
- `parse_splice_dots()` - Find splice point dot positions (circle paths)
- `parse_all_polylines()` - Extract all polylines (including routing)
- `parse_st17_polylines()` - Extract vertical routing polylines
- `parse_st17_paths()` - Extract ground connection paths
- `parse_st1_paths()` - Extract white routing wire paths
- `parse_routing_paths(only_l_shaped=True)` - Extract L-shaped routing paths (st3/st4) with vertical segments
- `extract_wire_specs()` - Find wire specifications (diameter, color)
- `extract_path_endpoints()` - Extract start and end points from path 'd' attribute
- `extract_path_all_points()` - Extract all points along a path (for multi-segment polylines)
- `map_splice_positions_to_dots()` - Map SP* labels to actual dot positions
- `generate_ids_for_unlabeled_splices()` - Generate custom IDs (SP_CUSTOM_*) for dots without labels

### Connector Finder (connector_finder.py)

Core logic for finding connectors above pins with sophisticated junction handling:

```python
def find_connector_above_pin(
    pin_x: float,
    pin_y: float,
    text_elements: List[TextElement],
    prefer_as_source: bool = False,
    source_x: float = None
) -> Optional[Tuple[str, float, float]]:
    """
    Implements:
    - Euclidean distance sorting
    - Junction pair detection
    - "Between" logic: picks junction physically between source and destination
    - Type-specific selection:
      * MH junctions: pick closer to PIN (tightly packed)
      * FTL junctions: pick closer to SOURCE (spread out)
    """
```

### Extractors Package (extractors/)

The extraction logic is organized into a modular package with a base class and specialized extractors:

#### Base Extractor (base_extractor.py)

`BaseExtractor` provides shared utilities for all extractors:

```python
class BaseExtractor:
    def __init__(self, text_elements: List[TextElement], wire_specs: List[WireSpec]):
        self.text_elements = text_elements
        self.wire_specs = wire_specs

    def _find_wire_spec_for_rectangular_polyline(self, path_points) -> Tuple[str, str]:
        """Find wire spec on LONGEST horizontal segment of rectangular polyline."""
        # Returns (diameter, color) from longest horizontal segment

    def _find_wire_spec_near_path(self, path_points, source_point=None) -> Tuple[str, str]:
        """Find wire spec closest to routing path, prioritizing segment near source."""
        # Returns (diameter, color) from horizontal segment closest to source
```

Also includes `deduplicate_connections()` function for global deduplication.

#### Specialized Extractors

**1. HorizontalWireExtractor** (`horizontal_wire_extractor.py`)
   - Wire-centric algorithm for horizontal wires with specs
   - Groups connection points by horizontal line (±10 Y units)
   - Creates connections between ALL ADJACENT PAIRS on same line
   - Handles junction selection with source_x context
   - Primary extractor for most connections

**2. HorizontalColoredWireExtractor** (`horizontal_colored_wire_extractor.py`)
   - Handles horizontal colored wires in non-grid diagrams
   - Uses wire color flow instead of wire specs

**3. VerticalRoutingExtractor** (`vertical_routing_extractor.py`) **[inherits BaseExtractor]**
   - Processes st17 polylines (vertical routing arrows)
   - Processes st1 paths (white routing wires)
   - Processes st3/st4 paths (L-shaped routing wires with vertical segments)
   - Processes rectangular polylines (4-point H-V-H pattern)
   - Tracks pass-through splices (splices with horizontal wires on both sides)
   - Finds nearest connection points to polyline/path endpoints
   - Handles multi-segment polylines with intermediate splices
   - Filters routing connections between two pass-through splices
   - Allows connections from pass-through splices to pins
   - Uses inherited methods for wire spec detection
   - Deduplicates before returning

**4. GroundConnectionExtractor** (`ground_connection_extractor.py`) **[inherits BaseExtractor]**
   - Processes st17 paths (ground connection arrows)
   - Finds connection points within 120 units of path arrow
   - Only creates connections involving ground connectors (with parentheses)
   - Prefers *2FL junction variants
   - Deduplicates before returning

**5. LongRoutingConnectionExtractor** (`long_routing_connection_extractor.py`)
   - Handles long-distance splice-to-splice connections
   - Uses wire color flow to trace multi-hop paths

**6. GridWireExtractor** (`grid_wire_extractor.py`)
   - Handles grid-based routing diagrams
   - Different coordinate system from standard diagrams

#### Why the Refactoring?

The original `extractors.py` file grew to **2175 lines** with 6 complex extractor classes. This created several challenges:

- **Navigation**: Finding specific logic required scrolling through thousands of lines
- **Code Duplication**: Wire spec detection methods were duplicated in multiple extractors
- **Testing**: Difficult to test individual extractors in isolation
- **Maintenance**: Changes to one extractor risked breaking others
- **Onboarding**: New contributors faced a steep learning curve

The modular architecture solves these by:
1. **Single Responsibility**: Each file has one clear purpose (~150-400 lines)
2. **Inheritance**: `BaseExtractor` eliminates duplication of wire spec logic
3. **Encapsulation**: Changes to one extractor don't affect others
4. **Discoverability**: File names clearly indicate what each extractor does
5. **Extensibility**: New diagram types can add extractors without modifying existing code

#### BaseExtractor Inheritance Pattern

```python
# VerticalRoutingExtractor inherits shared utilities
from .base_extractor import BaseExtractor

class VerticalRoutingExtractor(BaseExtractor):
    def __init__(self, polylines, routing_paths, text_elements, wire_specs, horizontal_connections):
        # Initialize base class with shared data
        super().__init__(text_elements, wire_specs)
        # Initialize extractor-specific data
        self.polylines = polylines
        self.routing_paths = routing_paths
        # ...

    def extract_connections(self):
        # Use inherited method for rectangular polylines
        wire_spec = self._find_wire_spec_for_rectangular_polyline(path_points)

        # Use inherited method for normal routing paths
        wire_spec = self._find_wire_spec_near_path(path_points, source_point)
```

**Extractors using BaseExtractor:**
- `VerticalRoutingExtractor` - Uses both inherited wire spec methods
- `GroundConnectionExtractor` - Uses `_find_wire_spec_near_path()`

**Extractors NOT using BaseExtractor:**
- `HorizontalWireExtractor` - Has its own wire spec logic (groups by horizontal line)
- `HorizontalColoredWireExtractor` - Uses color flow, no wire specs
- `LongRoutingConnectionExtractor` - Uses color flow, no wire specs
- `GridWireExtractor` - Different coordinate system, independent logic

### Critical: Ground Connection Distance Threshold

```python
# Ground connections use stricter distance filtering
if y_dist < 10 and x_dist < 120:  # 120 units, not 200
    # Connection point is valid
```

This prevents distant splice points from being incorrectly associated with ground arrows.

### Execution Flow

```python
# Imports from modular architecture
from extractors import (
    HorizontalWireExtractor,
    VerticalRoutingExtractor,
    GroundConnectionExtractor,
    deduplicate_connections
)
from models import IDGenerator
from svg_parser import (
    parse_text_elements,
    parse_splice_dots,
    parse_all_polylines,
    parse_st17_paths,
    parse_st1_paths,
    parse_routing_paths,
    map_splice_positions_to_dots,
    generate_ids_for_unlabeled_splices,
    extract_wire_specs
)
from output_formatter import export_to_file

# 0. Initialize ID generator for unlabeled splice points
id_generator = IDGenerator()

# 1. Parse all SVG elements
text_elements = parse_text_elements(svg_file)
splice_dots = parse_splice_dots(svg_file)
all_polylines = parse_all_polylines(svg_file)  # All polylines (including routing)
st17_paths = parse_st17_paths(svg_file)  # Ground connection paths
st1_paths = parse_st1_paths(svg_file)  # White routing wires
routing_paths = parse_routing_paths(svg_file, only_l_shaped=True)  # L-shaped routing wires

# 2. Map splice positions
text_elements = map_splice_positions_to_dots(text_elements, splice_dots)

# 2b. Generate custom IDs for unlabeled splice dots
text_elements = generate_ids_for_unlabeled_splices(text_elements, splice_dots, id_generator)

# 3. Extract wire specs
wire_specs = extract_wire_specs(text_elements)

# 4. Run extractors independently
horizontal_connections = HorizontalWireExtractor(text_elements, wire_specs).extract_connections()

# Combine st1 and st3/st4 routing paths for vertical routing extractor
all_routing_paths = st1_paths + routing_paths
routing_connections = VerticalRoutingExtractor(
    all_polylines, all_routing_paths, text_elements, horizontal_connections
).extract_connections()

ground_connections = GroundConnectionExtractor(st17_paths, text_elements, horizontal_connections).extract_connections()

# 5. Combine and deduplicate globally
combined = horizontal_connections + routing_connections + ground_connections
all_connections = deduplicate_connections(combined)

# 6. Export
export_to_file(all_connections, output_file)
```

## Usage

```bash
python extract_connections.py
```

**Input:** `sample-wire.svg` (Adobe Illustrator SVG export)

**Output:** `connections_output.md` (Markdown table of all connections)

## For AI Agents

If you're an AI agent working with similar SVG files, see **[wire-relation-prompt.md](wire-relation-prompt.md)** for a complete prompt that captures all the critical knowledge and rules from this project.

## Key Files

**Core Modules:**
- `extract_connections.py` - Main entry point and orchestration
- `models.py` - Data structures (Connection, TextElement, WireSpec, IDGenerator)
- `svg_parser.py` - SVG parsing utilities for text, paths, polylines
- `connector_finder.py` - Connector identification and sophisticated junction handling
- `output_formatter.py` - Output formatting and markdown export

**Extractors Package (`extractors/`):**
- `base_extractor.py` - Base class with shared wire spec detection utilities
- `horizontal_wire_extractor.py` - Primary extractor for wires with specs
- `vertical_routing_extractor.py` - Routing wires, polylines, rectangular paths
- `ground_connection_extractor.py` - Ground connections (st17 paths)
- `horizontal_colored_wire_extractor.py` - Color flow-based extraction
- `long_routing_connection_extractor.py` - Multi-hop splice connections
- `grid_wire_extractor.py` - Grid-based diagrams

**Test Files:**
- `sample-wire.svg` - Example circuit diagram
- `test_cases/` - Additional test SVG files
- `connections_output.md` - Generated connection table output
- `diagram.png` - Visual reference of the circuit

## Vertical Routing and Ground Connections

### 5. Vertical Routing Arrows (st17 Polylines)

Some connections use vertical routing arrows instead of horizontal wires with specs. These are encoded as `<polyline class="st17">` elements.

**Examples:**
- FL2FTL pin 8 → SP023
- FL7210B pin 3 → SP025
- FL7611 pins 1, 5, 9 → SP025

**Algorithm:**
```python
def extract_vertical_routing_connections(svg_file, text_elements):
    # Find all st17 polyline elements
    polylines = root.findall('.//polyline[@class="st17"]')

    for polyline in polylines:
        # Parse points: "x1,y1 x2,y2 x3,y3 ..."
        points = polyline.get('points').split()
        start = points[0]  # First point
        end = points[-1]   # Last point

        # Find nearest pin/splice to each endpoint (within 100 units)
        endpoint1 = find_nearest_connection_point(start_x, start_y)
        endpoint2 = find_nearest_connection_point(end_x, end_y)

        # Determine direction: splice points are ALWAYS destinations
        if is_splice_point(endpoint1):
            source, dest = endpoint2, endpoint1
        elif is_splice_point(endpoint2):
            source, dest = endpoint1, endpoint2
        else:
            # Use Y-coordinate: higher up = destination
            source, dest = (endpoint1, endpoint2) if start_y > end_y else (endpoint2, endpoint1)
```

**Multi-Segment Polylines:**

Some polylines connect multiple pins to one splice via intermediate points:

```python
# Example: 5-point polyline connecting FL7611 pins 1 and 9 to SP025
points = "718.4,678.9 800.6,678.9 800.6,384.4 781,653 718,653"

# Check if both endpoints are pins and there's a splice in the middle
if len(points) > 2 and both_endpoints_are_pins:
    for intermediate_point in middle_points:
        intermediate = find_nearest_connection_point(px, py)
        if is_splice_point(intermediate):
            # Create TWO connections:
            # 1. endpoint1 → splice
            # 2. endpoint2 → splice
            break
```

### 6. Ground Connections (st17 Paths)

Ground connections (e.g., to `G22B(m)`) use `<path class="st17">` elements as arrowheads.

**Ground Connector Pattern:**
```regex
^[A-Z]+\d+[A-Z]*\([a-z]\)$
```

**Examples:** `G22B(m)`, `G05(z)`

**Algorithm:**
```python
def extract_ground_connections(svg_file, text_elements):
    # Find all st17 path elements
    paths = root.findall('.//path[@class="st17"]')

    for path in paths:
        # Parse M command to get arrow location
        d = path.get('d')  # e.g., "M977.9,384.4c-29.2,0,-191.9,0,-217.4,0..."
        path_x, path_y = extract_M_coordinates(d)

        # Find connection points on same horizontal line
        # Within ±10 Y units AND ±200 X units of arrow
        connection_points = []
        for elem in text_elements:
            y_dist = abs(elem['y'] - path_y)
            x_dist = abs(elem['x'] - path_x)

            if y_dist < 10 and x_dist < 200:
                if is_pin(elem):
                    # For ground connections, prefer *2FL junction variant
                    connector = find_connector_above_pin_prefer_2FL(elem)
                    connection_points.append((elem['x'], connector, pin, elem['y']))
                elif is_ground_connector(elem):
                    connection_points.append((elem['x'], elem['content'], '', elem['y']))

        # Only create connection if one endpoint is a ground connector
        # This filters out regular routing already handled by horizontal wires
        if has_ground_connector(connection_points):
            # Find pair with maximum X distance
            # Create connection: pin → ground
```

**Critical: Junction Connector Selection for Ground**

When a pin is shared by junction connectors (e.g., FL2MH and MH2FL both above pin 73), ground connections prefer the `*2FL` variant:

```python
# For ground connections at junction pins
connectors_above = find_all_connectors_above_pin(pin_x, pin_y)

# Prefer *2FL pattern (MH2FL, FTL2FL) for ground wires
to_fl_variants = [c for c in connectors_above if c.endswith('2FL')]
if to_fl_variants:
    return to_fl_variants[0]  # e.g., MH2FL instead of FL2MH
```

**Example:** MH2FL pin 73 → G22B(m)

**Why:** Ground wires come from the destination/input side of junction connectors.

### Connection Type Summary

| Type | Element | Example | Wire Specs |
|------|---------|---------|------------|
| Horizontal wires | Text: wire specs | FL2MH pin 1 → FL7210 pin 4 | 0.35,GY/PU |
| Vertical routing | `<polyline class="st17">` | FL7210B pin 3 → SP025 | None |
| Ground connections | `<path class="st17">` | MH2FL pin 73 → G22B(m) | None |

**Final Statistics:**
- 48 horizontal wire connections (with wire specs)
- 5 vertical polyline routing connections
- 1 ground path connection
- **Total: 54 connections**

## Optional Exclusion Configuration

### Reference-Only Pins

Some circuit diagrams contain reference sections showing connector pins that point to external diagrams. These pins should not create connections within the current diagram.

**Solution:** Create an optional `exclusions_config.json` file to specify pins to exclude:

```json
{
  "description": "Optional exclusion configuration for reference-only pins",
  "exclusions": [
    {
      "connector_id": "RRS111",
      "pin": "22",
      "reason": "Reference connection to external diagram"
    },
    {
      "connector_id": "RRS111",
      "pin": "23",
      "reason": "Reference connection to external diagram"
    }
  ],
  "notes": [
    "Only exclude pins that ONLY connect to text labels or external references",
    "If a pin has valid connections to connectors/splices, keep those connections"
  ]
}
```

### Implementation

The extractor automatically loads `exclusions_config.json` if present:

```python
# Load exclusions
exclusions = load_exclusions('exclusions_config.json')

# Apply after extraction and deduplication
all_connections = apply_exclusions(all_connections, exclusions)
```

### Smart Filtering Logic

**Key Rule:** Exclusions are applied at the connection level, not the pin level.

- If a pin is in the exclusion list AND connects to a valid connector/splice → connection is excluded
- If a pin has multiple connections, ALL connections involving that pin are excluded
- The exclusion prevents false connections to text labels or reference sections

**Example:**

```
RRS111 pin 22 → RRS114 pin 2  ❌ Excluded (RRS111,22 in exclusion list)
RRS111 pin 23 → GND1 pin 13   ❌ Excluded (RRS111,23 in exclusion list + GND1 is a label)
SP113 → RR622 pin 26          ✓ Kept (SP113 not in exclusion list, valid connection)
```

### When to Use Exclusions

Use exclusion configuration for:
1. **Reference sections** with arrows pointing to external diagrams
2. **Connector detail boxes** showing internal wiring that shouldn't connect
3. **Description labels** inside dashed connector frames (e.g., GND1, GND2)

Do NOT use exclusions for:
- Splice points that have valid connections to other connectors
- Pins that connect to actual ground connectors (e.g., G22_B(m))
- Any pin that has legitimate wire connections in the diagram

## Future Improvements

- Support for other SVG export tools (Inkscape, AutoCAD, etc.)
- Configurable Y-axis tolerance based on diagram scale
- Automatic detection of wire specs near vertical routing paths
- Validation against physical connector pin counts
- Export to CSV, JSON, or Excel formats
- we are in windows command (windows 11 pro), we have git bash, github cli and other cli installed